# - 9 EVIL BASH COMMANDS EXPLAINED

Andreas Müller 氏による [9 Evil Bash Commands Explained](https://dev.to/devmount/9-evil-bash-commands-explained-4k5e) の非公式日本語訳です。  
自分用で作りました。

# 9 つの超危険な Bash コマンド一覧

初めて「ターミナル」を触った事のことを私は覚えています。  
黒いウィンドウに文字を入力するだけで、全てのファイルにアクセスでき、全てのプログラムを実行でき、システム全てを完全に支配下に置ける事に気付いた時の感動。  
そして、全てを破壊し、回復不能にしてしまう事への恐怖を。

私は正確には「システム管理者」ではありませんが、何年以上も Linux/UNIX ベースのシステムで作業しており、その中で何度もコマンドを実行しようとして Enter キーを押すのを躊躇ったことがあります。

以下では、「何があっても使用してはならない」か、「非常に慎重に実行する必要がある」コマンドをいくつか紹介します。  
bash を初めて扱うユーザーならば新しいことが学べることを期待しており、  
bash 経験者であるならコマンドの説明を見る前に何が起こるか自分で推測してみてください。

注意: 以下のコマンドは私が集めたものですが、いくつかは[別の投稿](https://www.cyberciti.biz/tips/my-10-unix-command-line-mistakes.html)からも確認できます。  
そして、最後の警告です。  
**⚠ 重要なシステムでこれらのコマンドを実行してはいけません！⚠**

## 1. 破壊的ディレクトリ変更 ( Destructive directory changing )

古典的な `rm -rf /*` でもいいのですが、たまには別バリエーションを。

```bash
alias cd='rm -rf'
```

### 💡 何が起こるの？

- `alias`コマンドは、エイリアスやショートカットを指定する bash コマンドです。  
  構文は `alias alias_name='command_to_run'` のようになります。
- `cd` は `Change Directory` の略です。
- `rm -rf` は実行するコマンドです。これは決して「高速メール読み取り (Read Mail - realfast)」といった意味ではありません。  
  「指定されたディレクトリの中身を警告なしに全て削除する」といったものです。

あなたが一瞬だけ席を外した隙に、悪意のある人間が開いたままのウィンドウにちょっとだけ文字を入力することができたとしたら？  
席に戻りディレクトリを移動しようとした後、深い絶望に襲われる事でしょう。

幸いにも `alias` コマンドは、ターミナルのセッション開始時に読み込まれるファイル（`~/.bashrc`など）に記述されていない限り、現在開いているセッション中でしか有効になりません。

### 🛡 どうやって防ぐの？

新しいエイリアスを追加する際、単に追加するだけではなく再確認が必要です。  
`alias` で現在のエイリアスを確認することができ、 `unalias alias_name` で既存のエイリアスを削除できます。

いつのまにかファイルが削除されることを防ぐため、`~/.bashrc`に以下のエイリアスを追加しておくことをオススメします。

```bash
alias rm='rm -i'
```

これにより、なにか別のコマンドのエイリアスに `rm` が仕込まれていたとしても、削除する前に確認することができます。  
_ちなみに、このコマンドでは簡単に破壊することができません。  
ルートディレクトリでの実行は `--no-preserve-root` が必要になります。_

## 2. メモリかじり虫 ( Memory-eater )

信じられないかもしれませんが、以下はれっきとした bash コマンドです。

```bash
:(){:|: &};:
```

### 💡 何が起こるの？

簡単に言えば、終了条件なしの再帰処理です。

まず、`:`という関数を定義します。  
これは関数内で自分を 2 回呼び出しています。  
最後の`:`で最初の関数呼び出しをします。  
すなわち、分かりやすく書くと以下のようになります。

```bash
evil () {
  evil|evil &
}
evil
```

これは Forkbomb とも言われ、実行すると全てのメモリと CPU リソースをすぐに食い潰します。  
システム全体がフリーズしてしまう可能性のある、DoS 攻撃の一種です。  
僅か 12 バイトのコマンドでこのような攻撃が実行できるのは驚くべき事でしょう。

### 🛡 どうやって防ぐの？

繰り返しや再帰する bash 関数を使っている場合は、適切に終了するよう条件を確認し、隔離されたテスト環境で実行してください。

Forkbomb はプロセスを無制限に起動するため、システムを保護する唯一の方法はローカルユーザーが実行できるプロセスの数を制限する事です。  
`/etc/security/limits.conf` を編集することで制限できます。  
ユーザー 1 人あたり 200 から 300 程度のプロセスを同時に使用するため、全体で 2000 プロセス程度に制限することで制限を厳しくしすぎる事なくシステムを Forkbomb から防御することができます。

## 3. メモリーゼロ ( Zero Memory )

```bash
dd if=/dev/zero of=/dev/sda
```

### 💡 何が起こるの？

- `dd` はあるファイルやデバイスから別の何かにデータをコピーするコマンドです。
- `if=` にはコピー元のファイル/デバイスを指定し、 `/dev/zero` は null で埋め尽くされた無制限のリソースです。
- `of=` にはコピー先のファイル/デバイスを指定し、 `/dev/sda` はディスクドライブです。

まとめると、これはディスク全体を消去する優れた方法であり、大量のデータを失える最速手段です。

### 🛡 どうやって防ぐの？

残念ですが、 `rm` にあるような `-i` のようなオプションは存在しません。  
`dd` コマンドで指定するデバイスが本当に正しい物であるか確認するしかありません。  
ちょっとでもリスクがあるのなら `dd` コマンドを実行しないでください。

```bash
alias dd='echo "no dd command available"'
```

このエイリアスを登録しておけば、 `dd` は動作しなくなります。

## 4. 回復不能 ( Zero recovery )

上記コマンドの別バージョンも考えられます。

```bash
for i in {1..10};do dd if=/dev/urandom of=/dev/sda;done
```

### 💡 何が起こるの？

これによりディスク全体がランダムバイトで 10 回上書きされるため、データ復旧の可能性が更に低下します。

### 🛡 どうやって防ぐの？

これも `dd` コマンドを使用するため、同じ方法で回避できます。

## 5. 未コミット、完全喪失 ( Uncommited and lost )

```bash
git reset --hard
```

### 💡 何が起こるの？

- `git reset` は git リポジトリの HEAD を最後に commit した時点にリセットします。
- `--hard` はワーキングツリーをリセットします。

要は最後の commit 以降のワーキングツリーの変更は全て破棄されます。

言い換えると、 commit してないあらゆる変更がなかった事になります。  
git はそれらを追跡していないため、復元する方法は一つもありません。

### 🛡 どうやって防ぐの？

単純です。 `--hard` オプションを利用しなければいい話です。  
使う必要が出てきた場合は、保存しておかねばならないローカル変更が存在しないかを確認してください。  
`git status` の出力が空であるか、 commit していないデータを全て確実に削除したい場合にのみハードリセットを行うことを推奨します。

## 6. 圧縮式破壊 ( Demolition by compression )

```bash
tar -czvf /path/to/file archive.tgz
# ↓のつもり
tar -czvf archive.tgz /path/to/file
```

### 💡 何が起こるの？

- `tar -czvf` は新しいアーカイブを作成し、gzip 圧縮し、詳細を画面に出力し、アーカイブを指定したファイルに出力します。
- `archive.tgz` は出力するファイル名です。
- `/path/to/file` は圧縮する対象のパスです。

この順番はとても重要です。  
圧縮したいファイルを 1 番目に持ってきてしまった場合、tar はそのファイルを上書きしてアーカイブの作成を行ってしまいます。  
その後 2 番目に指定されたファイルを見に行くもそれが存在しないことに気が付くため、最初のファイルは破壊されてしまいます。  
これは、ファイルのバックアップを行おうとして引数の順番を間違えてしまった場合には特に深刻になります。

### 🛡 どうやって防ぐの？

全てのオプションを一括指定するのではなく、 `-f` オプションのみ分離しまたロングオプションを使うことでわかりやすくなります。

```bash
tar -czv --file archive.tgz /path/to/file/to/compress
```

## 7. 多すぎる許可 ( Too many rights )

```bash
chmod -R 777 /
# ↓のつもり
chmod -R 777 ./
```

### 💡 何が起こるの？

- `chmod -R` はそのファイルの権限を再帰的に変更します。
- `777` は権限の指定で、あらゆる操作を許可します。
- `./` は変更対象のディレクトリまたはファイルです。

対象ディレクトリとしてうっかりルートディレクトリを指定してしまうと、システム全体の権限が破壊されてしまい、再起不能になってしまいます。

### 🛡 どうやって防ぐの？

`chmod` には `--preserve-root` が指定可能です。

```bash
alias chmod='chmod --preserve-root'
```

これにより、ルートディレクトリからの再帰的 chmod は拒否されるようになります。

## 8. 諸悪の根源 ( The root of all evil )

所有者の変更にも同じミスが起こりえます。

```bash
chown -R root:root /
# ↓のつもり
chown -R root:root ./
```

### 💡 何が起こるの？

- `chown -R` は所有者を再帰的に変更します。
- `root:root` は所有者とグループの指定です。
- `./` は変更対象のディレクトリもしくはファイルです。

このコマンドは OS の再インストールが必要になる可能性が最も高く、全てのファイルを使用不能にしてしまいます。

### 🛡 どうやって防ぐの？

対処法も `chmod` と同じです。

```bash
alias chown='chown --preserve-root'
```

これにより、ルートディレクトリからの再帰的 chown は拒否されます。

## 9. 暗号化と破壊活動 ( Encrypted and destroyed )

```bash
fsck -y /dev/sda
```

### 💡 何が起こるの？

- `fsck` はファイルシステムのチェックを行います。
- `-y` は検出されたファイルシステムの破損を自動的に修正するオプションです。
- `/dev/sda` はチェック対象のボリュームです。

これは良い事だと言えるでしょう。  
ただし、暗号化されたボリュームの場合は必ずしもそうであるとは限りません。  
暗号化されているボリュームに `fsck -y` を実行すると、完全に破壊されてしまいます。

### 🛡 どうやって防ぐの？

暗号化されていない通常のボリュームであることを確認した上で `fsck` を使用してください。

## 最後に

ちょっとしたコマンドを打つだけで、データを破壊したりシステムをダメにするのが非常に・とてつもなく簡単であることがわかりました。

結論として、最善の方法は何かを実行する前に「何を入力しようとしているのか把握し」「タイプミスを確認すること」です。  
コマンドのコピペではありません。bash コマンドに置いては真実なのかもしれませんが...。

また、常にバックアップ体制も取っておきましょう。

上記コマンドの殆ど全ては root 権限が必要になります。  
そのため、root で作業する際はより一層注意する必要があります。

他にもヤバいコマンドを知っている人がいたら、是非コメントで教えて下さい。

免責事項: 上記コマンドを試してシステムに重大な損害を与えてしまったとしても、私は責任を追いません。  
          テストしたいのであれば仮想マシンのような、完全に安全な環境を用意してください。  
          警告はしましたからね。

## コメント欄

- 最上部に注意書き置いといた方がいいよ。どんだけ悪い事か理解してない人がいるかも。
  - ありがとう。追加しといたよ！
- 4 番をもっと強化してみたよ。並列モードで OpenSSL の AES 暗号を使用し、ランダムなパスワードでプレーンゼロのストリームを暗号化するんだ。それを sda に書き込んで破壊する。

```bash
openssl enc -aes-256-ctr -pass pass:"$(dd if=/dev/urandom bs=128 count=1 2>/dev/null | base64)" -nosalt </dev/zero > /dev/sda1
```

- これ BOFH っぽいね。
  - わかる！
- この前見かけた evli.sh の Forkbomb についてよく分からなかったけど、コレ見て理解できた！

# 感想

```
あなたはシステム管理者から通常の講習を受けたはずです。
これは通常、以下の3点に要約されます:
    #1) 他人のプライバシーを尊重すること。
    #2) タイプする前に考えること。
    #3) 大いなる力には大いなる責任が伴うこと。
```